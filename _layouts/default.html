<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>{{ page.title | default: site.title }}</title>
    {% seo %}
  <link rel="stylesheet" href="/assets/custom.css">
  </head>
  <body>
    {% include nav.html %}

    <main class="site-main">
      <div class="container">
        {{ content }}
      </div>
    </main>

    <footer class="site-footer">
      <div class="container">
        <p>&copy; {{ site.title }} Â· {{ site.time | date: '%Y' }}</p>
      </div>
    </footer>

    <script>
    // Site theme controller: reads stored preference, falls back to system, and exposes toggle
    (function(){
      const root = document.documentElement;
      function getStored(){ return localStorage.getItem('site-theme'); }
      function setTheme(t){
        root.setAttribute('data-theme', t);
        localStorage.setItem('site-theme', t);
        document.dispatchEvent(new CustomEvent('theme-changed',{detail: t}));
        updateToggle(t);
      }
      function prefersDark(){ return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; }
      function init(){
        const stored = getStored();
        let theme = stored || (prefersDark() ? 'dark' : 'light');
        if(stored === 'system') theme = (prefersDark() ? 'dark' : 'light');
        root.setAttribute('data-theme', stored === 'system' ? 'system' : theme);
        updateToggle(stored || 'auto');
      }
      function updateToggle(state){
        const btn = document.getElementById('theme-toggle'); if(!btn) return;
        const sun = document.getElementById('icon-sun'); const moon = document.getElementById('icon-moon');
        if(state === 'dark'){ btn.setAttribute('aria-pressed','true'); if(sun) sun.style.display='none'; if(moon) moon.style.display='inline-block'; btn.title='Dark mode'; }
        else if(state === 'light'){ btn.setAttribute('aria-pressed','false'); if(sun) sun.style.display='inline-block'; if(moon) moon.style.display='none'; btn.title='Light mode'; }
        else { btn.setAttribute('aria-pressed','false'); if(sun) sun.style.display='inline-block'; if(moon) moon.style.display='none'; btn.title='Match OS'; }
      }
      function toggle(){ const stored = getStored(); if(stored === 'system' || stored === null){ const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'; setTheme(cur === 'dark' ? 'light' : 'dark'); } else { const cur = stored === 'dark' ? 'dark' : 'light'; setTheme(cur === 'dark' ? 'light' : 'dark'); } }
      function setSystem(){ localStorage.setItem('site-theme','system'); document.documentElement.removeAttribute('data-theme'); document.dispatchEvent(new CustomEvent('theme-changed',{detail: (prefersDark() ? 'dark' : 'light')})); updateToggle('auto'); }

      // attach
      document.addEventListener('DOMContentLoaded', function(){
        init();
        const tb = document.getElementById('theme-toggle'); if(tb) tb.addEventListener('click', toggle);

        // Theme menu wiring: reveal on focusin, hide on focusout, close on Esc
        const menu = document.getElementById('theme-menu');
        if(menu){
          menu.addEventListener('focusin', ()=> menu.setAttribute('aria-hidden','false'));
          menu.addEventListener('focusout', ()=> { setTimeout(()=>{ if(!menu.contains(document.activeElement)) menu.setAttribute('aria-hidden','true'); }, 10); });

          // Buttons inside the theme menu
          const btnLight = document.getElementById('theme-light');
          const btnDark = document.getElementById('theme-dark');
          const btnSystem = document.getElementById('theme-system');
          if(btnLight) btnLight.addEventListener('click', function(){ setTheme('light'); menu.setAttribute('aria-hidden','true'); });
          if(btnDark) btnDark.addEventListener('click', function(){ setTheme('dark'); menu.setAttribute('aria-hidden','true'); });
          if(btnSystem) btnSystem.addEventListener('click', function(){ setSystem(); menu.setAttribute('aria-hidden','true'); });
          
            // Focus trap for the menu when open
            const menuButton = document.getElementById('theme-menu-button');
            if(menuButton){
              menuButton.addEventListener('click', function(e){
                const isOpen = menu.getAttribute('aria-hidden') === 'false';
                menu.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
                menuButton.setAttribute('aria-expanded', (!isOpen).toString());
                if(!isOpen){
                  // focus first focusable item
                  const first = menu.querySelector('[role="menuitem"]'); if(first) first.focus();
                } else {
                  menuButton.focus();
                }
              });
            }

            function trapFocusInMenu(e){
              if(menu.getAttribute('aria-hidden') === 'true') return;
              const focusable = Array.from(menu.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el=>!el.hasAttribute('disabled'));
              if(focusable.length === 0) return;
              const first = focusable[0]; const last = focusable[focusable.length-1];
              if(e.key === 'Tab'){
                if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
                else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
              }
              if(e.key === 'Escape'){
                menu.setAttribute('aria-hidden','true'); menuButton && menuButton.focus();
              }
            }
            menu.addEventListener('keydown', trapFocusInMenu);
        }

        // Close menu on Escape anywhere
        document.addEventListener('keydown', function(e){ if(e.key === 'Escape'){ const m = document.getElementById('theme-menu'); if(m && m.getAttribute('aria-hidden') === 'false') m.setAttribute('aria-hidden','true'); } });
      });

      // When theme changes, notify giscus iframes (global sync)
      document.addEventListener('theme-changed', function(e){
        const effective = e.detail || document.documentElement.getAttribute('data-theme');
        // Map 'system' to actual light/dark value
        const theme = (effective === 'system') ? (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : effective;
        document.querySelectorAll('iframe.giscus-frame, iframe.giscus-iframe, iframe').forEach(function(iframe){
          try{
            iframe.contentWindow.postMessage({giscus: {setConfig: {theme: theme}}}, 'https://giscus.app');
          }catch(_){ /* ignore cross-origin/frame access errors */ }
        });
      });

      // Helper: post theme to giscus frames and optionally retry if none present yet
      function getEffectiveTheme(explicit){
        const eff = explicit || document.documentElement.getAttribute('data-theme');
        if(eff === 'system'){
          return (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light';
        }
        if(!eff){
          return (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light';
        }
        return eff;
      }

      function postToGiscus(theme){
        const frames = Array.from(document.querySelectorAll('iframe.giscus-frame, iframe.giscus-iframe, iframe'));
        frames.forEach(function(iframe){
          try{ iframe.contentWindow.postMessage({giscus: {setConfig: {theme: theme}}}, 'https://giscus.app'); }catch(_){}
        });
        return frames.length;
      }

      // On DOMContentLoaded, ensure giscus receives the current theme. Retry a few times
      document.addEventListener('DOMContentLoaded', function(){
        const themeNow = getEffectiveTheme();
        // dispatch a theme-changed event to run any other listeners as well
        document.dispatchEvent(new CustomEvent('theme-changed', { detail: themeNow }));

        // try posting immediately and retry if no frames found
        let attempts = 0;
        const maxAttempts = 4;
        const retry = function(){
          attempts += 1;
          const sent = postToGiscus(themeNow);
          if(sent === 0 && attempts < maxAttempts){
            // exponential-ish backoff: 300ms * attempts^2
            const delay = 300 * Math.pow(attempts, 2);
            setTimeout(retry, delay);
          }
        };
        retry();
      });
    })();
    </script>
  </body>
</html>
